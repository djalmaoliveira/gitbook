diff --git a/text/34_Git_Submodules/1_Submodules.markdown b/text/34_Git_Submodules/1_Submodules.markdown
old mode 100644
new mode 100755
index 39cd410..80af9c9
--- a/text/34_Git_Submodules/1_Submodules.markdown
+++ b/text/34_Git_Submodules/1_Submodules.markdown
@@ -1,47 +1,47 @@
-## Submodules ##
-
-Large projects are often composed of smaller, self-contained modules.  For
-example, an embedded Linux distribution's source tree would include every
-piece of software in the distribution with some local modifications; a movie
-player might need to build against a specific, known-working version of a
-decompression library; several independent programs might all share the same
-build scripts.
-
-With centralized revision control systems this is often accomplished by
-including every module in one single repository.  Developers can check out
-all modules or only the modules they need to work with.  They can even modify
-files across several modules in a single commit while moving things around
-or updating APIs and translations.
-
-Git does not allow partial checkouts, so duplicating this approach in Git
-would force developers to keep a local copy of modules they are not
-interested in touching.  Commits in an enormous checkout would be slower
-than you'd expect as Git would have to scan every directory for changes.
-If modules have a lot of local history, clones would take forever.
-
-On the plus side, distributed revision control systems can much better
-integrate with external sources.  In a centralized model, a single arbitrary
-snapshot of the external project is exported from its own revision control
-and then imported into the local revision control on a vendor branch.  All
-the history is hidden.  With distributed revision control you can clone the
-entire external history and much more easily follow development and re-merge
-local changes.
-
-Git's submodule support allows a repository to contain, as a subdirectory, a
-checkout of an external project.  Submodules maintain their own identity;
-the submodule support just stores the submodule repository location and
-commit ID, so other developers who clone the containing project
-("superproject") can easily clone all the submodules at the same revision.
-Partial checkouts of the superproject are possible: you can tell Git to
-clone none, some or all of the submodules.
-
-The linkgit:git-submodule[1] command is available since Git 1.5.3.  Users
-with Git 1.5.2 can look up the submodule commits in the repository and
-manually check them out; earlier versions won't recognize the submodules at
-all.
-
-To see how submodule support works, create (for example) four example
-repositories that can be used later as a submodule:
+﻿## Submodules ##
+
+Grandes projetos muitas vezes são compostos de pequenos módulos auto-contidos.
+Por exemplo, uma árvore de código fonte de uma distribuição Linux embarcada
+incluirá cada software na distribuição com algumas modificações locais; pode ser
+que um player de filme precise ser construido em cima de uma específica e bem 
+trabalhada versão de uma biblioteca de descompressão; diversos programas 
+independentes podem compartilhar os mesmos scripts de construção.
+
+Com sistemas centralizados de controle de versão isso é muitas vezes talentoso
+pela inclusão de cada módulo em um simples repositório. Desenvolvedores podem
+baixar todos os módulos ou somente os módulos que eles precisam trabalhar.
+Eles podem até modificar arquivos pelos diversos módulos em um simples commit
+enquanto move coisas ou atualiza APIs e traduções.
+
+Git não permite checkouts parciais, então duplicando ele no Git forçará os
+desenvolvedores manter uma cópia local dos módulos que eles não estão
+interessados. Commits em grandes checkouts será mais lento do que você
+poderia esperar com o Git, ele terá que buscar cada diretório por alterações.
+Se os módulos tem muitos históricos locais, clones levarão uma eternidade.
+
+Por outro lado, sistemas de controle de revisão distribuida podem ser muito
+melhor integrados com fontes externas. No modelo centralizado, uma simples cópia
+arbitrária de um projeto externo é exportado de seu próprio controle de revisão e
+então importado para o controle de revisão local no branch do fornecedor. Todo
+o histórico está escondido. Com controle de revisão distribuida você pode clonar
+o histórico externo inteiro e muito mais fácilmente seguir o desenvolvimento e
+re-merge as alterações locais.
+
+O suporte a submodules no Git permite um repositório conter, como um
+sub-diretório, uma cópia de um projeto externo. Submodules mantém sua própria
+identidade; o suporte a submodule só armazena a localização do repositório do
+submodule e a identificação do commit, então outros desenvolvedores que clonarem
+o conteúdo do projeto ("superproject") podem facilmente clonar todos os submodules
+na mesma revisão.
+Checkouts parciais do superproject são possíveis: você pode chamar o Git para
+clonar nenhum, alguns, ou todos os submodules.
+
+O comando linkgit:git-submodule[1] está disponível desde o Git 1.5.3. Usuários com
+Git 1.5.2 podem procurar os commits do submodule no repositório e manualmente
+mover-se para eles; versões mais antigas não reconhecerão os submodules.
+
+Para ver como o suporte a submodule funciona, crie (por exemplo) quatro repositórios
+de exemplo que podem ser usados depois como submodule:
 
     $ mkdir ~/git
     $ cd ~/git
@@ -56,7 +56,7 @@ repositories that can be used later as a submodule:
 	    cd ..
     done
 
-Now create the superproject and add all the submodules:
+Agora crie um superproject e adicione todos os submodules:    
 
     $ mkdir super
     $ cd super
@@ -66,34 +66,34 @@ Now create the superproject and add all the submodules:
         git submodule add ~/git/$i
     done
 
-NOTE: Do not use local URLs here if you plan to publish your superproject!
+NOTA: Não use URLs locais aqui se você planeja publicar seu superproject!    
 
-See what files `git-submodule` created:
+Veja que arquivos `git-submodule` criou:
 
     $ ls -a
     .  ..  .git  .gitmodules  a  b  c  d
 
-The `git-submodule add` command does a couple of things:
+O comando `git-submodule` faz várias coisas:
 
-- It clones the submodule under the current directory and by default checks out
-  the master branch.
-- It adds the submodule's clone path to the linkgit:gitmodules[5] file and
-  adds this file to the index, ready to be committed.
-- It adds the submodule's current commit ID to the index, ready to be
-  committed.
 
-Commit the superproject:
+- Ele clona o submodule sobre o diretório atual e por padrão troca para o branch
+  master.
+- Ele adiciona o caminho do clone do submodule para o arquivo 
+  linkgit:gitmodules[5] e adiciona esse arquivo no index, pronto para o commit.
+- Ele adiciona a ID do commit atual do submodule no index, pronto para o commit.
+
+Commit o superproject:
 
 
     $ git commit -m "Add submodules a, b, c and d."
 
-Now clone the superproject:
+Agora clone o superproject:    
 
     $ cd ..
     $ git clone super cloned
     $ cd cloned
 
-The submodule directories are there, but they're empty:
+Os diretórios do submodule existem, mas estão vazios:    
 
     $ ls -a a
     .  ..
@@ -103,44 +103,45 @@ The submodule directories are there, but they're empty:
     -c1536a972b9affea0f16e0680ba87332dc059146 c
     -d96249ff5d57de5de093e6baff9e0aafa5276a74 d
 
-NOTE: The commit object names shown above would be different for you, but they
-should match the HEAD commit object names of your repositories.  You can check
-it by running `git ls-remote ../a`.
+NOTA: Os nomes dos objetos commit mostrado acima serão diferentes para você, 
+mas eles deverão corresponder aos nomes dos objetos commit do HEAD em seu 
+repositório. Você pode verificar ele executando `git ls-remote ../a`.
 
-Pulling down the submodules is a two-step process. First run `git submodule
-init` to add the submodule repository URLs to `.git/config`:
+Baixar os submodules é um processo de dois passos. Primeiro execute 
+`git submodule init` para adicionar a URL do repositório submodule para 
+`.git/config`:
 
     $ git submodule init
 
-Now use `git-submodule update` to clone the repositories and check out the
-commits specified in the superproject:
+Agora use `git-submodule update` para clonar o repositório e verificar os 
+commits especificados no superproject:    
 
     $ git submodule update
     $ cd a
     $ ls -a
     .  ..  .git  a.txt
 
-One major difference between `git-submodule update` and `git-submodule add` is
-that `git-submodule update` checks out a specific commit, rather than the tip
-of a branch. It's like checking out a tag: the head is detached, so you're not
-working on a branch.
+Uma das maiores diferenças entre `git-submodule update` e `git-submodule add` é
+que `git-submodule update` verifica um commit específico, ou melhor a ponta do 
+branch. Isso é como ir para uma tag: o head é isolado, então você não trabalha
+sobre o branch.
 
     $ git branch
     * (no branch)
     master
 
-If you want to make a change within a submodule and you have a detached head,
-then you should create or checkout a branch, make your changes, publish the
-change within the submodule, and then update the superproject to reference the
-new commit:
+Se você quer fazer uma alteração dentro de um submodule e você tem um head isolado,
+então você deverá criar ou mudar para um branch, fazer suas alterações, publicar a
+alteração dentro do submodule, e então atualizar o superprojetct para referenciar 
+o novo commit:
 
     $ git checkout master
 
-or
+ou
 
     $ git checkout -b fix-up
 
-then
+então:
 
     $ echo "adding a line again" >> a.txt
     $ git commit -a -m "Updated the submodule from within the superproject."
@@ -158,14 +159,14 @@ then
     $ git commit -m "Updated submodule a."
     $ git push
 
-You have to run `git submodule update` after `git pull` if you want to update
-submodules, too.
+Você tem que executar `git submodule update` depois `git pull` se você também 
+quer atualizar os submodules.      
 
-###Pitfalls with submodules
+###Armadilhas com submodules
 
-Always publish the submodule change before publishing the change to the
-superproject that references it. If you forget to publish the submodule change,
-others won't be able to clone the repository:
+Sempre publique a alteração do submodule antes de publicar as alterações para o
+superproject que referencia ele. Se você esquecer de publicar as alterações do
+submodule, outros não serão capazer de clonar o repositório.
 
     $ cd ~/git/super/a
     $ echo i added another line to this file >> a.txt
@@ -181,12 +182,12 @@ others won't be able to clone the repository:
     Did you forget to 'git add'?
     Unable to checkout '261dfac35cb99d380eb966e102c1197139f7fa24' in submodule path 'a'
 
-You also should not rewind branches in a submodule beyond commits that were
-ever recorded in any superproject.
+Você também deverá voltar branches em um submodule através de commits que sempre 
+foram gravados em qualquer superproject.
 
-It's not safe to run `git submodule update` if you've made and committed
-changes within a submodule without checking out a branch first. They will be
-silently overwritten:
+Isso não é seguro executar `git submodule update` se você tem feito e commitado
+alterações dentro do submodule sem verificar o branch primeiro. Eles serão
+sobrescritos silenciosamente:
 
     $ cat a.txt
     module a
@@ -199,8 +200,8 @@ silently overwritten:
     $ cat a.txt
     module a
 
-NOTE: The changes are still visible in the submodule's reflog.
+NOTA: As alterações ainda são visíveis no reflog dos submodules.    
 
-This is not the case if you did not commit your changes.
+Isso não é o caso se você não commitar suas alterações.
 
 [gitcast:c11-git-submodules]("GitCast #11: Git Submodules")
